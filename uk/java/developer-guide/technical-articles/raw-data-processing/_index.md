---
title: Обробка Сироих Даних
type: docs
weight: 70
url: /uk/java/raw-data-processing/
---

## **Обробка Сироих Даних**
Для покращення продуктивності Aspose.PSD API ми внесли метод обробки сироих даних із версією 2.4.0. Обробка сироих даних тепер використовується внутрішньо та має зовнішній API, щоб його можна було використовувати за межами бібліотеки для покращення загальної продуктивності. Іноді обробка стає трохи складною і потребує пояснення. Наразі обробка сироих даних доступна лише для формату BMP.

Для допомоги розробникам отримувати найкращу продуктивність, Aspose.PSD API надає систему обробки сироих даних, яка має зовнішній API для налаштувань. Розробники викликають методи LoadRawData та SaveRawData для використання обробки сироих даних. Ці методи також потребують вказати бажаний формат сирої даних, використовуючи клас RawDataSettings. Клас RawDataSettings дозволяє розробникам вказати будь-який формат сирої даних. Однак, щоб досягти найкращої продуктивності, вам потрібно використовувати формат сирої даних, у якому дані зберігаються. Клас RawDataSettings, визначений в класі RasterImage, допомагає визначити формат сирої даних зображення. Передаючи екземпляр RawDataSettings у метод LoadRawData, дані повертаються такими, які є, без застосування конвертації, і можуть покращити продуктивність. З іншого боку, вам потрібно дбати про всі можливі розташування форматів сирої даних, що іноді може бути трохи ускладненим.

Для спрощення процесу обробки, за рахунок певного штрафу у продуктивності, ви можете вказати бажані налаштування RawDataSettings, проініціювавши та ініціалізувавши клас з бажаними налаштуваннями сирої даних. Є випадки, коли неможливо повернути сирі дані у вказаному форматі (наприклад, конвертація з кольорового простору CMYK в RGB не доступна у версії 2.4.0). Більш того, можуть бути сценарії, коли обробка сироих даних взагалі недоступна для формату зображення. Для визначення можливості використання методів сірої даних LoadRawData та SaveRawData необхідно перевірити властивість IsRawDataAvailable.
### **Інсайт**
Для формату даних пікселів RGB доступні індексовані (на основі палітри) та RGB-основані формати сирої даних. Індексовані формати сирої даних містять індекси запису палітри в діапазоні 0..(2^ bis count - 1). Індексовані формати сирої даних - це 1, 2, 4 та 8 бітів на піксель. Решта - це RGB-основані формати сирої даних. Під час завантаження сирої даних слід врахувати, що наявно достатньо байтів для завантаження даних, інакше буде викинута відповідна виняткова ситуація. Ви можете просто оцінити розмір масиву байтів, помноживши розмір рядка на необхідну кількість рядків. Розмір рядка може варіюватися і залежить від формату зберігання сирої інформації.

Щоб досягти найкращої продуктивності завжди використовуйте розмір рядка сирої інформації, рівний значенню властивості RasterImage.RawLineSize. Однак іноді може знадобитися додаткова доповнюваність рядка сирої інформації, або його зменшення, і у випадку потреби використовуйте інший розмір рядка. Якщо потрібно підмножина обмеження прямокутника зображення, то враховуйте зсуви бітів, які можуть виникнути для індексованих форматів пікселів RGB. Наприклад, давайте розглянемо зображення з розмірами 100x100 пікселів і форматом сирої інформації 1 біт на піксель. Ви хочете завантажити прямокутник сирої інформації з розміщенням (7,0) та розмірами (2,1), або іншими словами, вам потрібно 2 пікселя, починаючи з x=7 та y=0. У цьому випадку ви повинні отримати таку структуру даних:

![todo:image_alt_text](raw-data-processing_1.png)

Це означає, що ви отримаєте 2 байти, де перший байт містить 7 небажаних пікселів, потім 1 бажаний піксель, і другий байт містить 1 бажаний піксель, а потім 7 небажаних. Ви можете запитати, чому ми не проводили зсув даних і не збирали ці 2 пікселя в один байт? Відповідь проста: для підтримки високої продуктивності. Усі внутрішні операції зазвичай виконуються з усією інформацією, починаючи з першого пікселя й закінчуючи останнім доступним пікселем. Є рідкісні ситуації, коли потрібна підмножина пікселів. Крім того, ми не маємо уявлення, які саме пікселі будуть оброблені далі, тому зсув знизить продуктивність і зробить код непотрібно складним. Завжди оцінюйте правильний біт (не потрібно визначати потрібний байт, оскільки дані завжди надходять з першим заповненим байтом), де почнуться запитані пікселі. Щоб обчислити правильний біт, можна використати просту формулу: (rect.Left * bitsCount) % 8.
### **Конверсія Індексованого RGB-кольору**
Щоб отримати максимально можливу продуктивність, завжди використовуйте однакові настройки джерела та цільові настройки сирої інформації, формати пікселів та розміри рядків. Однак іноді може знадобитися виконати конвертацію даних. Наприклад, ви можете завантажити зображення RGB з форматом 1 біт на піксель і зберегти його з форматом 2 біт на піксель, або завантажити зображення RGB з 4 бітовими пікселями та зменшити діапазон кольорів до 2 біт на піксель. В обох випадках слід застосувати конверсію кольорів. Конвертація індексованих зображень RGB іноді може бути складною та не може виконуватися без деяких налаштувань. Нам потрібно визначити, як діапазон кольорів джерела відображається у цільове кольорове простір. Для виконання цієї задачі ми маємо різні режими:

- Відображення палітри (DitheringMethods.PaletteConversion)
- Відображення сирої інформації (DitheringMethods.PaletteIgnore)
- Власна конверсія (DitheringMethods.CustomConverter)

При використанні конверсії палітри джерело кольорового простору намагається якомога точніше відповідати цільовому кольоровому простору. Наприклад, припустимо, що у нас є зображення 4 біт з наступними кольорами:
[0] RGB=0, 0, 0
[1] RGB=17, 17, 17
[2] RGB=34, 34, 34
[3] RGB=51, 51, 51
[4] RGB=68, 68, 68
[5] RGB=85, 85, 85
[6] RGB=102, 102, 102
[7] RGB=119, 119, 119
[8] RGB=136, 136, 136
[9] RGB=153, 153, 153
[10] RGB=170, 170, 170
[11] RGB=187, 187, 187
[12] RGB=204, 204, 204
[13] RGB=221, 221, 221
[14] RGB=238, 238, 238
[15] RGB=255, 255, 255

Джерело зображення виглядає наступним чином:

![todo:image_alt_text](raw-data-processing_2.png)

І ми конвертуємо 4-бітове зображення у 1-бітове зображення з наступними визначеними палітрними кольорами:

[0] RGB = 0, 0, 0
[1] RGB = 255, 255, 255

При використанні режиму конверсії палітри конвертер читає кольори джерела та визначає індекс цільової палітри, використовуючи метод GetNearestColorIndex палітри. Значення властивості RasterImage.RawFallbackIndex використовується в разі передачі поза діапазоном індексів методу GetNearestColorIndex палітри. Це конвертує джерело кольорів у найближчі цільові кольори за значеннями інтенсивності. Цільове зображення максимально відповідає джерелу. Ви можете побачити такий результат:

![todo:image_alt_text](raw-data-processing_3.png)

У режимі відображення сирої інформації використовується різний сценарій. Палітри кольорів джерела та цільові палітри просто ігноруються, індекси джерела відображаються на індекси призначення. Коли знайдено значення, яке не можна відобразити у цільовий діапазон (при зниженні кількості бітів), використовується значення властивості RasterImage.RawFallbackIndex. Значення за замовчуванням рівне 0 і буде відображено на перший колір у цільовій палітрі. Якщо значення цієї властивості знаходиться поза діапазоном цільового діапазону, буде викинута відповідна виняткова ситуація. Це призводить до менш передбачуваних результатів, які можна побачити на наступному зображенні:

![todo:image_alt_text](raw-data-processing_4.png)

Режим конверсії палітри є більш правильним рішенням для проблеми відображення кольорів, але він також займає трохи більше часу на завершення, оскільки потрібно виконати обчислення для оцінки правильної відображення паліт