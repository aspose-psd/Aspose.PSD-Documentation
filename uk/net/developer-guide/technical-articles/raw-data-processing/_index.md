---
title: Обробка необроблених даних
type: docs
weight: 50
url: /uk/net/raw-data-processing/
---

## **Обробка необроблених даних**
Для покращення продуктивності API Aspose.PSD ми внесли метод для обробки необроблених даних у версії 2.4.0. Обробка необроблених даних використовується внутрішньо та має зовнішнє API, щоб можна було використовувати його ззовні бібліотеки для покращення загальної продуктивності. Іноді обробка стає трохи складною і потребує пояснення. Зараз обробка необроблених даних доступна лише для формату BMP.

Для того, щоб розробники могли отримати найкращу продуктивність, API Aspose.PSD надає систему оброблення необроблених даних, яка має зовнішнє API для налаштування. Розробники викликають родину методів [LoadRawData](https://reference.aspose.com/psd/net/aspose.psd/rasterimage/methods/loadrawdata/index) та [SaveRawData](https://reference.aspose.com/psd/net/aspose.psd/rasterimage/methods/saverawdata) для використання обробки необроблених даних. Ці методи також вимагають встановлення бажаного формату необроблених даних за допомогою класу [RawDataSettings](https://reference.aspose.com/psd/net/aspose.psd/rawdatasettings). Клас RawDataSettings дозволяє розробникам вказати будь-який формат необроблених даних. Однак, для досягнення найкращої продуктивності, потрібно використовувати формат необроблених даних, у якому дані зберігаються. RawDataSettings, визначений в класі [RasterImage](https://reference.aspose.com/psd/net/aspose.psd/rasterimage), допомагає визначити формат необроблених даних [зображення](https://reference.aspose.com/psd/net/aspose.psd/rawdatasettings/properties/pixeldataformat). Передача екземпляра RawDataSettings у метод LoadRawData призводить до повернення даних такими, які вони є, без застосування конвертування, що може покращити продуктивність. З іншого боку, потрібно піклуватися про всі можливі формати розміщення необроблених даних, що іноді може бути трохи складним.

Для спрощення процесу оброблення, за ціною деякого погіршення продуктивності, можна вказати бажані RawDataSettings, створивши та ініціалізуючи клас з необхідними налаштуваннями для необхідних необроблених даних. Існують випадки, коли неможливо повернути необроблені дані у вказаному форматі (наприклад, конвертування з колірного простору CMYK в RGB недоступно у версії 2.4.0). Більше того, можуть виникнути ситуації, коли обробка необроблених даних взагалі не доступна для формату зображення. Щоб визначити, чи можна використовувати родину методів LoadRawData та SaveRawData, необхідно запитати властивість [IsRawDataAvailable](https://reference.aspose.com/psd/net/aspose.psd/rasterimage/properties/israwdataavailable).
### **Ініціатива**
Для формату пікселів RGB [пунктів даних](https://reference.aspose.com/psd/net/aspose.psd/pixeldataformat) доступні індексовані (на основі палітри) та RGB-піксельні формати необроблених даних. Індексовані формати необроблених даних містять індекси палітри в діапазоні 0..(2^цифр в бітах - 1). Індексовані формати необроблених даних – це 1, 2, 4 та 8 біт на піксель. Інші формати – це RGB-піксельні необроблені дані. При завантаженні необроблених даних слід пам'ятати, що для завантаження даних потрібно достатньо байтів, в іншому випадку буде викинуте відповідне виключення. Ви можете оцінити розмір масиву байтів, помноживши розмір рядка на необхідну кількість рядків. Розмір рядка може відрізнятися і залежить від формату зберігання необроблених даних.

Для досягнення найкращої продуктивності завжди використовуйте розмір рядка необроблених даних, який дорівнює значенню властивості [RasterImage.RawLineSize](https://reference.aspose.com/psd/net/aspose.psd/rasterimage/properties/rawlinesize). Проте іноді може знадобитися додаткове доповнення рядків необроблених даних або їх скорочення, і у цьому випадку може бути використаний інший розмір рядка. Якщо потрібно підмножина обмежуючого прямокутника зображення, то враховуйте бітові зсуви, які можуть виникати для індексованих RGB-піксельних форматів. Наприклад, розглянемо зображення з розмірами 100x100 пікселів і формат необроблених даних 1 біт на піксель. Ви хочете завантажити прямокутник необроблених даних із розташуванням (7,0) та розміром (2,1), або, іншими словами, вам потрібно 2 пікселя, починаючи з x=7 та y=0. У цьому випадку ви повинні отримати такий розміщення даних:



![todo:image_alt_text](raw-data-processing_1.png)

Це означає, що ви отримуєте 2 байти, де перший байт містить 7 непотрібних пікселів, потім 1 бажаний піксель, а другий байт містить 1 бажаний піксель і потім 7 непотрібних. Ви можете запитати, чому ми не здійснили зсув даних і не помістили ці 2 пікселя в один байт? Відповідь проста: для підтримки високої продуктивності. Всі внутрішні обчислення зазвичай виконуються з усіма даними, починаючи з першого пікселя і закінчуючи останнім доступним пікселем. Іноді виникають рідкісні ситуації, коли потрібно підмножину пікселів. Крім того, ми не маємо уявлення, як ці пікселі будуть оброблені після цього, тому зсув знизить продуктивність і зробить код зайво складним. Завжди оцінюйте потрібний біт (немає необхідності визначати правильний байт, оскільки дані завжди поставляються з першим заповненим байтом), де почнуться вимагані пікселі. Для розрахунку правильного біту можна використовувати просту формулу: (rect.Left * bitsCount) % 8.
### **Конверсія індексованого RGB кольору**
Для отримання максимальної продуктивності завжди використовуйте однакові налаштування необроблених даних джерела і призначення, формати пікселів і розміри рядків. Проте іноді може знадобитися конвертація даних. Наприклад, ви можете завантажити RGB-зображення з 1 бітом на піксель і зберегти його з 2 бітами на піксель, або завантажити зображення RGB з 4 бітами і зменшити його діапазон кольорів до 2 бітів на піксель. У будь-якому випадку, потрібно застосувати конверсію кольору. Конвертування індексованих RGB зображень іноді може бути складним і не може виконуватися без деяких налаштувань. Нам потрібно визначити, як діапазон кольору джерела відображається на цільовий кольоровий простір. Для досягнення цієї мети у нас є різні [режими](https://reference.aspose.com/psd/net/aspose.psd/ditheringmethods):

- Відображення палітри (DitheringMethods.PaletteConversion)
- Відображення необроблених даних (DitheringMethods.PaletteIgnore)
- Користувацька конверсія (DitheringMethods.CustomConverter)

При використанні відображення палітри, джерело кольорів намагається збігти з цільовим кольоровим простором якомога ближче. Наприклад, допустимо, у нас є зображення з 4 бітами і наступними кольорами:
[0] RGB=0, 0, 0
[1] RGB=17, 17, 17
[2] RGB=34, 34, 34
[3] RGB=51, 51, 51
[4] RGB=68, 68, 68
[5] RGB=85, 85, 85
[6] RGB=102, 102, 102
[7] RGB=119, 119, 119
[8] RGB=136, 136, 136
[9] RGB=153, 153, 153
[10] RGB=170, 170, 170
[11] RGB=187, 187, 187
[12] RGB=204, 204, 204
[13] RGB=221, 221, 221
[14] RGB=238, 238, 238
[15] RGB=255, 255, 255

Джерело зображення виглядає наступним чином:



![todo:image_alt_text](raw-data-processing_2.png)

І ми конвертуємо 4-бітне зображення в 1-бітне зображення з визначеними палітрними кольорами:

[0] RGB = 0, 0, 0
[1] RGB = 255, 255, 255

При використанні методу конвертації палітри, конвертер читає джерело кольорів та визначає індекс цільового показника за допомогою методу [GetNearestColorIndex](https://reference.aspose.com/psd/net/aspose.psd/icolorpalette/methods/getnearestcolorindex/index) цільової палітри. Значення властивості [RasterImage.RawFallbackIndex](https://reference.aspose.com/psd/net/aspose.psd/rasterimage/properties/rawfallbackindex) використовується у випадку, якщо метод GetNearestColorIndex палітри повертає індекс поза діапазоном. Це конвертує джерело кольорів в найближчі цільові кольори за інтенсивністю. Цільове зображення максимально наближається до джерела. Ви можете побачити наступний результат:


![todo:image_alt_text](raw-data-processing_3.png)

У режимі відображення необроблених даних використовується інший сценарій. Палітри джерела та цільовий кольори просто ігноруються, а індекси джерела відображаються на індекси цільової палітри. Якщо знайдено значення, яке не може бути відображено в цільовий діапазон (під час зниження кількості бітів), тоді використовується значення властив