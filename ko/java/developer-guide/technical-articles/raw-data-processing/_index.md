---
title: Raw Data Processing
type: docs
weight: 70
url: /ko/java/raw-data-processing/
---

## **Raw Data Processing**
Aspose.PSD API의 성능을 향상시키기 위해 2.4.0 버전에서 원시 데이터 처리 방법을 도입했습니다. 현재 원시 데이터 처리는 내부적으로 사용되며 외부 API를 가지고 있어 라이브러리 외부에서 전체 성능을 향상시키기 위해 사용할 수 있습니다. 가끔 처리가 약간 복잡할 수 있으며 설명이 필요할 수 있습니다. 현재 BMP 형식에 대해서만 원시 데이터 처리가 가능합니다.

개발자가 최상의 성능을 얻을 수 있도록 Aspose.PSD API는 외부 API를 가진 원시 데이터 처리 시스템을 제공합니다. 개발자들은 원시 데이터 처리를 사용하기 위해 LoadRawData 및 SaveRawData 메서드 패밀리를 호출합니다. 이러한 메서드들은 RawDataSettings 클래스를 사용하여 원하는 원시 데이터 형식을 설정해야 합니다. RawDataSettings 클래스를 사용하면 개발자들은 원시 데이터 형식을 지정할 수 있습니다. 그러나 최상의 성능을 얻으려면 데이터가 저장된 원시 데이터 형식을 사용해야 합니다. RasterImage 클래스에서 정의된 RawDataSettings는 이미지의 원시 데이터 형식을 결정하는 데 도움을 줍니다. RawDataSettings 인스턴스를 LoadRawData 메서드에 전달하면 변환을 적용하지 않고 데이터가 반환되어 성능을 향상시킬 수 있습니다. 그러나 때로는 모든 가능한 원시 데이터 형식 레이아웃을 고려해야 합니다.

처리 과정을 간단하게 하기 위해 성능에 약간의 페널티를 치르고 원하는 RawDataSettings를 지정할 수 있습니다. 때로는 지정된 형식으로 원시 데이터를 반환할 수 없는 경우(예: CMYK 색 공간에서 RGB로의 변환이 2.4.0 버전에서 지원되지 않음)가 있을 수 있습니다. 또한 이미지 형식에 대해 전혀 원시 데이터 처리를 사용할 수 없는 시나리오가 있을 수 있습니다. LoadRawData 및 SaveRawData 메서드 패밀리를 사용할 수 있는지 여부를 확인하려면 IsRawDataAvailable 속성을 쿼리해야 합니다.

### **통찰**
RGB 픽셀 데이터 형식의 경우 팔레트 기반 및 RGB 기반 원시 데이터 형식이 있습니다. 팔레트 기반 원시 데이터 형식에는 0..(2의 비트 수 - 1) 범위의 팔레트 항목 인덱스가 포함됩니다. 팔레트 기반 원시 데이터 형식은 1, 2, 4, 8 비트가 있습니다. 나머지는 RGB 기반 원시 데이터 형식입니다. 원시 데이터를 로드할 때 데이터를 로드하는 데 충분한 바이트가 있는지 주의해야 하며, 그렇지 않은 경우 적절한 예외가 발생할 수 있습니다. 데이터를 로드하는 데 필요한 바이트 배열 크기를 간단히 예측할 수 있습니다. 라인 크기는 원시 데이터 저장 형식에 따라 다를 수 있습니다.

최상의 성능을 달성하려면 항상 RasterImage.RawLineSize 속성 값과 같은 원시 데이터 라인 크기를 사용해야 합니다. 그러나 때로는 원시 데이터 행에 추가적인 패딩을 추가하거나 줄일 경우 다른 라인 크기를 사용해야 할 수 있습니다. 이미지 바운딩 사각형의 하위 집합이 필요한 경우에는 RGB 픽셀 형식에 대한 비트 시프트를 고려해야 합니다. 예를 들어, 100x100 픽셀 크기의 이미지가 있고, 픽셀 당 1비트의 원시 데이터 형식을 로드하려면 x=7 및 y=0에서 시작하는 지정된 크기의 원시 데이터 사각형이 필요합니다. 이 경우 다음 데이터 레이아웃을 받아야 합니다:

![할 일:이미지 대체 텍스트](raw-data-processing_1.png)

즉, 첫 번째 바이트에는 7개의 원하지 않는 픽셀, 그리고 1개의 원하는 픽셀이 포함되어 있고, 두 번째 바이트에는 1개의 원하는 픽셀, 그리고 7개의 원하지 않는 픽셀이 포함되어 있습니다. 우리가 왜 데이터 시프트를 수행하지 않고 이러한 2개 픽셀을 하나의 바이트로 넣지 않았는지 궁금할 수 있습니다. 답은 간단합니다. 성능을 유지하기 위함입니다. 모든 내부 처리는 일반적으로 첫 번째 픽셀에서 시작하여 마지막으로 사용 가능한 픽셀로 끝납니다. 픽셀 하위 집합이 필요한 드문 경우가 있습니다. 또한, 이러한 픽셀이 이후에 어떻게 처리될지 알 수 없으므로 시프트는 성능을 낮출 뿐만 아니라 코드를 불필요하게 복잡하게 만듭니다. 요구되는 픽셀이 시작할 적절한 비트를 추정하십시오. 적절한 비트를 계산하기 위해 간단한 공식을 사용할 수 있습니다: (rect.Left * bitsCount) % 8.

### **색상 변환**
가능한 최상의 성능을 달성하려면 항상 동일한 소스 및 대상 원시 데이터 설정, 픽셀 형식 및 라인 크기를 사용해야 합니다. 그러나 때로는 데이터 변환이 필요할 수 있습니다. 예를 들어, 1비트 픽셀 RGB 이미지를 로드하고 2비트 픽셀로 저장하거나, 4비트 RGB 이미지를로드하고 색 범위를 2비트 픽셀로 다운그레이드해야 하는 경우가 있습니다. 어느 경우든 색상 변환을 적용해야 합니다. 팔레트 형식의 RGB 이미지 변환을 수행하는 것은 때로는 까다로울 수 있고 설정을 적용하지 않으면 수행할 수 없습니다. 소스 색상 범위가 대상 색 공간으로 매핑되는 방법을 결정해야 합니다. 이 작업을 수행하기 위해 다음 모드가 있습니다:

- 팔레트 매핑(DitheringMethods.PaletteConversion)
- 원시 데이터 매핑(DitheringMethods.PaletteIgnore)
- 사용자 정의 변환(DitheringMethods.CustomConverter)

팔레트 변환을 사용하면 소스 색 공간이 가능한 한 대상 색 공간과 가장 가까운 색을 매칭하려고 합니다. 예를 들어 다음과 같은 색상을 가진 4비트 이미지가 있다고 가정해 봅시다:
[0] RGB=0, 0, 0
[1] RGB=17, 17, 17
...
[15] RGB=255, 255, 255

소스 이미지는 다음과 같이 생겼습니다:

![할 일:이미지 대체 텍스트](raw-data-processing_2.png)

그리고 4비트 이미지를 다음과 같이 정의된 1비트 이미지로 변환합니다:

[0] RGB = 0, 0, 0
[1] RGB = 255, 255, 255

팔레트 변환 모드에서 변환기는 소스 색상을 읽고 대상 팔레트의 GetNearestColorIndex 메서드를 사용하여 대상 인덱스를 결정합니다. 팔레트의 GetNearestColorIndex 메서드가 범위를 벗어나는 인덱스를 줄 경우 RasterImage.RawFallbackIndex 속성 값이 사용됩니다. 이는 소스 색상을 강도 값 측면에서 가능한 한 가까운 대상 색상으로 변환합니다. 대상 이미지는 소스 이미지와 가능한 한 가깝게 일치합니다. 다음 결과를 확인할 수 있습니다:

![할 일:이미지 대체 텍스트](raw-data-processing_3.png)

원시 데이터 매핑 모드에서 다른 시나리오가 사용됩니다. 소스 및 대상 색상 팔레트는 단순히 무시되며 소스 인덱스는 대상 인덱스로 매핑됩니다. 값을 찾으면 대상 범위로 매핑할 수 없는 값이 발견되면(RGB 비트 카운트를 낮추는 경우) RasterImage.RawFallbackIndex 속성 값이 사용됩니다. 기본값은 0이고 대상 팔레트에서 첫 번째 색상으로 매핑됩니다. 이 속성 값이 대상 범위 밖에 있다면 적절한 예외가 발생합니다. 이는 예측할 수 없는 결과를 초래하며 다음 이미지에서 표시될 수 있습니다:

![할 일:이미지 대체 텍스트](raw-data-processing_4.png)

팔레트 변환 모드는 색 매핑 문제에 대한 더 정확한 해결책이지만 올바른 팔레트 매핑을 추정하기 위해 계산이 수행되어 조금 더 많은 시간이 걸릴 수 있습니다. (일반적으로 두 방법 간에는 매우 작은 성능 차이가 있습니다.) 반면, 원시 매핑 모드는 조금 더 빠르게 수행되며 정확한 색 매핑이 그다지 중요하지 않은 경우에 사용할 수 있습니다. 예를 들어, 소스 색상 팔레트가 충분히 작아져도 안전하게 더 작은 비트 수로 변환할 수 있기 때문입니다.

이러한 접근 방식 중 하나를 사용하려면 RasterImage 클래스의 RawDitheringMethod 속성을 사용하십시오. 기본적으로 시작하기 전에 속성을 변경하여 최상의 결과를 얻을 수 있습니다. 이미지를 스트림으로 저장하는 경우와 같이 변환이 발생하기 전에 이 속성을 변경할 수 있습니다. 이미지를 로드하고 일부 원본 픽셀 데이터를 다시 작성한 경우 캐시에 새 데이터가 들어가며 캐시는 데이터를 최대 사용 가능한 형식인 32ARGB로 저장합니다(2.4.0 버전 기준, 변경될 수 있음). 이 형식은 로드된 이미지와 저장된 이미지의 가능한 다른 색 조합으로 인한 문제를 극복하기 위해 사용됩니다. 더 나아가 이미지가 RGB 모드로 로드되고 인덱스 모드로 변환되거나 그 반대로 변환될 때 팔레트 무시 및 팔레트 변환 디더링 방법은 무시됩니다.

### **사용자 정의 색 변환기**
가끔은 색 변환에 대한 표준 접근 방법만으로는 충분하지 않을 수 있습니다. 색 변환 루틴을 사용할 때 완벽한 자유를 얻고 싶을 수도 있습니다. 소스 및 대상 이미지의 픽셀 형식이 모두 인덱스 RGB 형식인 경우 더 간단한 인터페이스인 IIndexedColorConverter를 사용할 수 있습니다. RasterImage.RawIndexedColorConverter 속성을 IIndexedColorConverter 인스턴스로 설정하고 RawDitheringMethod 속성 값으로 DitheringMethods.CustomConverter를 사용해야 합니다. 이 조합이 함께 사용될 때 모든 인덱스된 색상 변환이 지정된 IIndexedColorConverter 인스턴스를 통해 수행됩니다. 사용자 지정 인덱스된 컬러 컨버터에는 다음이 정의되어 있습니다:

```java
void FillIndexedtoIndexedMap(byte[] map, PixelDataFormat sourceFormat, PixelDataFormat destFormat);
```

FillIndexedtoIndexedMap 메서드는 인덱스 RGB 이미지에서 인덱스 RGB 이미지 형식으로 변환이 필요한 경우 호출됩니다(1, 2, 4 또는 8 비트 모두가 서로 변환되는 경우). 맵 배열은 모든 가능한 소스 형식 항목 수의 길이를 가지고 있습니다. 해당 배열을 채워서 소스 색상 팔레트 항목에서 대상 색상 팔레트 항목까지 매핑해야 합니다. 대상 인덱스 값이 0..(비트 수 - 1) 범위에 있어야 하며 그렇지 않은 경우 적절한 예외가 발생합니다.

더 맞춤화된 색상 변환 시나리오를 실행해야 할 경우 RasterImage.RawCustomColorConverter 속성을 IColorConverter 인스턴스로 설정해야 합니다. 만일 IColorConverter 인터페이스의 단일 메서드가 있습니다:

```java
int Convert(PixelDataFormat sourceFormat, byte[] data, int offset, int bitStart, int samplesCount, int linesCount, PixelDataFormat destFormat, byte[] outputData, int outputOffset);
```

Convert 메서드는 각 색상 변환이 필요할 때마다 호출됩니다. 이 메서드는 소스 형식의 소스 원시 데이터를받고 대상으로 변환된 색상을받을 출력 버퍼가 있습니다. 출력 버퍼는 변환된 데이터를 수신할 수 있을 정도로 충분해야 합니다(인터페이스 호출이 Aspose.PSD 라이브러리 내부에서 이루어진다면) 이후에는 복귀된 원시 데이터를 포함해야하며 메서드를 반환합니다. Convert 메서드는 전체 소스 데이터가 처리될 때까지 여러 번 호출될 수 있습니다.